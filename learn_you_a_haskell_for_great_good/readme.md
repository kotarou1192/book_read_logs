# すごいHaskell楽しく学ぼう

discordに読んでる途中の感想やメモをたくさん残してたので、それを追加。
以後はここにメモすることに。

## この本is何

純粋関数型言語のHaskellを扱うためのチュートリアル本。  
扱い方や考え方を親切に解説している。  

## 感想とか

第1版 第12刷についての感想

### 1章

Haskellの紹介などが書いてある。

### 2章

型についてのかんたんな解説。  
型クラスがここで初登場。

### 3章

関数の基礎的な書き方について学ぶ。

### 4章

再帰関数について学ぶ。

### 5章

高階関数周りについて学ぶ。  
カリー化と部分適用について学ぶ。  

**カリー化と部分適用の違いは大事。**  
カリー化は引数を減らす事ができるようにすること。  
部分適用はカリー化された関数に一部だけの引数を与えること。  

### 6章

モジュールの作り方について学ぶ。

### 7章

型や型クラスを自分で定義する方法について学ぶ。  
再帰的なデータ構造やその型がどうやって求められるかについても学ぶ。  

### 8章

I/O周りについての基礎を学ぶ。  
標準入出力を利用する。

### 9章

ファイルに対してのI/Oを学ぶ。  
とても大きなファイルを開いても、遅延評価によってメモリを食いつぶさずに処理することが出来る。  
このあたりから実践的なコードが出現し始める。

### 10章

様々な問題を関数型言語のアプローチで解く。  

- 逆ポーランド記法で書かれた文字列を関数型言語で計算する
- 単純な最短経路問題

### 11章

結構重いかもしれないので個人の見解を書いておく。

#### ファンクターについておさらいする

##### ファンクタ―ってなんやねん

- 箱的ななにか
- ある関数を使って操作（コピー）できるもの
- 任意のネストに対して任意にネストできるもの
- リストだったりMap[k, v]だったり
  - vがintだったりstringだったり混在してしたら、操作に使うある関数がその2つを受け取れなければならない。お手上げっぽい。
  - なおファンクターの定義は、具体型を一つ取って具体型を返す関数。

#### 実は関数もファンクターだった

##### 関数もファンクタ―ってどういうことなん

- 関数fに何らかの引数aを入力するとなにかが帰ってくることを(-> a)と表す
- 関数a -> bはa型のなにか入力するとbが帰ってくるもの
- 関数(-> a) bは上に同じ
- ネストしまくった(-> (-> (-> (-> a) b) c) d) は a -> b -> c -> d
  - あれ、どっかで見たことあるやんね

#### むしろファンクターは関数っぽい

純粋関数型だしまあたしかに。  

- 引数aをとり、何かを返す関数
  - 引数bをとり、何かを返す関数
    - ...
      - 引数xを取り、intを返す関数

これってa, b...xを取るとintを返す関数だよね、みたいな。  
このintが[]だったら…？

#### ファンクターがファンクタ―であるために

##### ルールその1

idでなにか入ってるファンクタ―を写してもファンクターの中身が変わってはいけない
(idと\x -> xは等価)  
副作用がないことの確認みたいなものだと思う。id (+2) 3ってid 2 + 3で、その結果が毎回変わったら怖い。  

##### ルールその2

なにか入ってるファンクターaを関数fとgで操作するときに
**f (g a)とf . g aが返すなにか入ってたファンクタ―bが等しい**  
カリー化できることを保証するのかもしれない。  

##### ルールその3(ファンクタ―則)

ルールその1とルールその2を破るな

#### もっと抽象的（汎用的）なアプリカティブファンクタ―

普通のファンクタ―だとファンクターの中に入った何かを外側に取り出す一般的な方法がない。つまり中身をいじれない。  
でも、ファンクターの中身に関数を入れて、ファンクター同士で対象のファンクタ―に対してfmapすると、ファンクターの中身をいじることが出来る。  
そう、アプリカティブならね！  
ファンクターの中の世界に行って関数を適用しているように見える。  

リスト内包表記をアプリカティブ・スタイルで置き換えることができることがある。  

### 12章

モノイドについて学ぶ。  

#### newtypeとdataって何が違うん

評価のされ方が違う。  

dataは複数の型を持っている可能性がある -> どれが何なのかわからない -> わかる限界まできっちり評価される（たとえ中身が1つだとしても）  
newTypeは既存の型1つを新しい型に変換する -> 中身はわかりきってるので重要じゃない -> 必要になるまで評価されない  

**undefined(評価された瞬間に例外が発生する)などを扱うと違いがわかる。**  

#### typeっていうものもなかった？newTypeと何が違うん？

- typeは別名をつけるだけ -> 型コンストラクタとか作らない -> 何も変えないので属していた型クラスとかそのまま  
- newtypeは1つの任意の型を新しい型にする -> コンストラクタができ、元の型と別物になる -> 型クラスとかがもとの型から引き継がれず綺麗サッパリ消滅する
- dataは任意個数の任意の型を全く新しい型にする(それ以外はnewtypeと同じ)

#### Monoid型クラスって何

モノイドな型  

##### モノイドってなんやねん

1 + 2 + 3は3 + (1 + 2)とも表せる。同様に2 \* 3 \* 4は2 \* (3 \* 4)と等価（**統合的という**）。  
2 \* 1は2で、3 \* 1は3になる。[1, 2] \+\+ \[\]は[1, 2]になって[3, 4] \+\+ \[\]は[3, 4]になる。  
なんかこういうやつ。  

###### もっと抽象的に言うと

引数を2つ取る関数がある場合  

- a b -> cの型a, b, cはすべて同じ
- 関数に与える引数a bとその返り値cにおいてb == cになるa または a == cになるbが存在する
  - この時のaまたはbを単位元と呼ぶ

統合的な2引数の関数(二項演算子)を持ち、単位元があるものがモノイド。  
なお、モノイドのインスタンスは具体型でなければならない。  
モノイドじゃないモノイドも作ることが出来るが、それはモノイドっぽくなくて使いづらいのでやめたほうがいい。  

#### モノイドになれる（として扱える）例

- なにかのリストというモノイド
- 比較できそうななにかのモノイド
- なにかMaybeなモノイド
- 数
  - 足し算モノイド、掛け算モノイド、...
- Bool
  - Any(or)モノイド、All(and)モノイド
- あなたのモノイド

#### だから何なのか

foldできそうななにか(foldable)があるとする。
monoidは大体fold出来るので、fold出来る(foldableな)ものをmonoidにできる。そしたらfoldrとかfoldlとか色々自動でついてくる。つまりそれはだいたいmonoid。  
あとmonoidは具体値なので、monoidが複数集まってできたデータ構造を単一のmonoidに畳み込んだり出来る。なぜならmonoidはだいたいfoldableだから（要件を満たさないmonoidモドキをあなたが無理やり定義しない限り）。  
何を言っているのかわからないなら、つまり何を言っているのかわからないということだ。  

### 13章

ついにモナドが出てくる

#### モナドってなに

アプリカティブファンクターが進化したもの。  
(applicate=適用する…application=応用…)  
言い換えると、文脈付きの値。  
(Just 1とか)  

##### なんのためにあるん

i/oやMaybeの中身を関数でいじりたいとかそういうニーズがあるらしい。  
え、それってアプリカティブファンクターじゃないの？？？ -> そのとおりで、すべてのモナドはアプリカティブファンクター。  

##### monadの定義

アプリカティブファンクターの定義とだいたい一緒。  
リスト内包表記はリストモナドの糖衣構文。  

##### モナドだと何がどう嬉しいの

任意の文脈を載せた関数チェーンみたいなことがかんたんに出来る。  
任意の文脈とは、例えばある条件によって失敗、成功とか、非決定性があるとか。  
try-catch文的なことも出来る。  
JSのPromiseチェーンみたいなことができたり、さすがいろんな言語に影響を与えているだけはある。  
でも手続き型っぽく表現すると多分怒られる。  

#### モナドがモナドであるために

アプリカティブファンクターのように、いくつか決まりがある。  
なお、守らなくてもモナドのインスタンスには出来るが、それはモナドとは呼べない。  

##### ルールその一

モナドの中で扱っているなにかであるxと、それに適用する関数fにおいて  
f xはreturn x >>= fと等価でなければならない。  

##### ルールその二

何らかのモナド値xがある場合、x >>= returnの結果はxに等くなければならない。

##### ルールその三

あるモナドに>>=を使って関数を適用する連鎖がある時、関数の連鎖の順番を変更しても結果が同じでなければならない。

##### ルールその四

ルールを破るな

### 14章
